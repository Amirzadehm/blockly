#summary How to define new blocks.
#labels Phase-Implementation

*[CustomBlocks Creating Custom Blocks]: Defining Blocks*

= Defining a Block =

Go to the `language/` directory, and open the subdirectory containing the human language you wish to develop with (`en/` is English).

Assuming your block(s) don't fit in the existing categories, create a new !JavaScript file.  It should start with this definition:
{{{
if (!Blockly.Language) Blockly.Language = {};
}}}

This new !JavaScript file needs to be included in the list of `<script ...>` tags in the editor's HTML file.

A typical block definition looks like this:
{{{
Blockly.Language.text_length = {
  category: 'Text',
  helpUrl: 'http://www.w3schools.com/jsref/jsref_length_string.asp',
  init: function() {
    this.setColour(160);
    this.setOutput(true, Number);
    this.appendInput('length', Blockly.INPUT_VALUE, 'VALUE', String);
    this.setTooltip('Returns number of letters in the provided text.');
  }
};
}}}

http://blockly.googlecode.com/svn/wiki/text_length.png

  * `text_length` is the name of the block.  Since all blocks share the same namespace, it is good to use a name made up of your category (in this case `text`) followed by your block's function (in this case `length`).
  * `category` is the text of the menu option in Blockly's main toolbar which will contain the block.  Categories are listed in the order they are loaded, so if your blocks are appearing in the wrong place, move your `<script ...>` tag higher or lower with respect to the other language definitions.
  * `helpUrl` is the URL of the page which should open when the user right-clicks on the block and chooses help.  If this value is `null` then the menu will be greyed out.  Advanced blocks may specify a function (instead of a static string) which returns a URL string, thus allowing for dynamic help.
  * `init` is a function which defines the look and feel of the block.

== Init Function ==

The `init` function creates the block's shape.  In the context of this function the keyword `this` is the actual block being created.  There are several functions commonly used in an `init` function:

  * [#setColour setColour]
  * [#setOutput setOutput]
  * [#setPreviousStatement setPreviousStatement]
  * [#setNextStatement setNextStatement]
  * [#appendTitle appendTitle]
  * [#appendInput appendInput]
  * [#setInputsInline setInputsInline]
  * [#setTooltip setTooltip]
  * [#setMutator setMutator]

=== setColour ===

{{{
    this.setColour(160);
}}}
Blockly uses a [http://en.wikipedia.org/wiki/HSL_and_HSV Hue-Saturation-Value] (HSV) colour model.  Saturation and Value are hard-coded into Blockly, whereas the Hue is defined on each block.  This ensures that developers have the freedom to choose from a wide range of colours, while still guaranteeing that all the blocks will fit together visually.  It also allows the entire Blockly look and feel to be made brighter (for children) or more depressing (for businesses) by simply adjusting the two hard-coded Saturation and Value constants.

http://blockly.googlecode.com/svn/wiki/HSV.png

To find a good colour, visit this [http://www.yafla.com/yaflaColor/ColorRGBHSL.aspx HSV picker], enter Blockly's Saturation and Value constants (the defaults are 45% and 65% respectively), then slide the Hue as desired.  Use this Hue value as the argument to the `this.setColour` function.  Note the British spelling.  Failure to set the colour results in a black block.

=== setOutput ===

{{{
    this.setOutput(true, Number);
}}}

http://blockly.googlecode.com/svn/wiki/setOutput.png

Value blocks (as opposed to statements) need an output tab.  Blocks with an output tab may not also have a previous statement notch.

This function also defines the expected value type that this block will output.  A block that outputs a number will refuse to connect to a block that inputs a string (e.g. `length(123)` does not make sense).  Blockly uses `Boolean`, `Number`, `String`, and `Array` as constants for the built-in types.  If creating a new type, use a short descriptive string, such as `"Date"`.

In the event that the block could return more than one type of value, use an array of types (e.g. `[Number, "Date"]`).  If the block could return any type of value (such as a variable's getter block), use `null` as the value.

=== setPreviousStatement ===

{{{
    this.setPreviousStatement(true);
}}}

http://blockly.googlecode.com/svn/wiki/setPreviousStatement.png

Creates a notch at the top of the block, so that it may be plugged into a stack of statements.  Normally combined with `setNextStatement` (see below).  Blocks with a previous statement notch may not also have an output tab.

Optionally (and not typically), this function can take a second argument to limit the types of statements this block may be connected to.

=== setNextStatement ===

{{{
    this.setNextStatement(true);
}}}

http://blockly.googlecode.com/svn/wiki/setNextStatement.png

Creates a notch at the bottom of the block, so that other statements may be stacked below it.  Unless this block terminates flow (e.g. break, return, or end), this is normally combined with `setPreviousStatement` (see above).

Optionally (and not typically), this function can take a second argument to limit the types of statements this block may be connected to.

=== appendTitle ===

{{{
    this.appendTitle('hello');
}}}

http://blockly.googlecode.com/svn/wiki/appendTitle.png

A block contains a title row, which can contain any number of title elements.  The simplest title element is text.  Blockly's convention is to use all lowercase text, with the exception of proper names (e.g. Google, SQL).

{{{
    var textInput = new Blockly.FieldTextInput('Neil');
    this.appendTitle(textInput, 'NAME');
}}}

http://blockly.googlecode.com/svn/wiki/appendTitleTextInput.png

Another title element is a text input field.  First, create the field, then append it to the title row.  Since the code generators will eventually need to access the data in this title element, be sure to give it a name (in this case `'NAME'`).  This name is never seen by the user and should be consistent across all human language versions of the block.

Optionally, the `FieldTextInput` constructor can also take a second argument which becomes the validation function.  See `math_number` for an example of where the user's input is rewritten.

{{{
    var dropdown = new Blockly.FieldDropdown([['world', 'WORLD'], ['computer', 'CPU']]);
    this.appendTitle(dropdown, 'MODE');
}}}

http://blockly.googlecode.com/svn/wiki/appendTitleDropdown.png

Another title element is a dropdown menu.  Just like the text input field, the dropdown menu is created separately, then appended to the title row.  The `FieldDropdown` object is created with a list of menu options.  Each option is made up of two strings.  The first is the human-readable text to display.  The second is a string constant which is used when saving the option to XML.  This separation allows a dropdown menu's setting to be preserved between languages.  For instance an English (`en/`) version of a block may define `[['left', 'LEFT'], ['right', 'RIGHT']]` while a German (`de/`) version of the same block would define `[['links', 'LEFT'], ['rechts', 'RIGHT']]`.

Instead of providing a static list of options, one can provide a function that returns a list of options when called.  This allows for dynamic menus.  See `variables_get` got an example.

Optionally, the `FieldDropdown` constructor can also take a second argument which becomes the validation function.  See the English version of `text_trim` for an example of where changing a dropdown modifies a title.

=== appendInput ===

{{{
    this.appendInput('item', Blockly.LOCAL_VARIABLE, 'VAR').setText('x');
    this.appendInput('in list', Blockly.INPUT_VALUE, 'LIST', Array);
    this.appendInput('do', Blockly.NEXT_STATEMENT, 'DO');
}}}

http://blockly.googlecode.com/svn/wiki/appendInput.png

Each block has a list of inputs for referencing variables, connecting value blocks, or enclosing a stack of statements.

==== Label ====

The first argument to `appendInput` specifies the label for the input.  In most cases this is just a static string (e.g. `'item'`, `'in list'`, and `'do'` in the example above).  However, the label can also be an editable field, such as an input field or a dropdown.

{{{
    var dropdown = new Blockly.FieldDropdown([['and', 'AND'], ['or', 'OR']]);
    this.appendInput([dropdown, 'OP'], Blockly.INPUT_VALUE, 'BOOL', Boolean);
}}}

In the example above, the first argument to `appendInput` is a two element list; the first element is the editable field, and the second element is a language-neutral name (in this case `'OP'`) which allows code generators to access the field.  See [#appendTitle appendTitle] for more details on editable fields.

If no label is desired, simply use the empty string.

==== Type ====

The second argument to `appendInput` specifies the type of the input.  There are four options:

  * `Blockly.LOCAL_VARIABLE` - A variable dropdown.
  * `Blockly.INPUT_VALUE` - A socket in which to plug a value block.
  * `Blockly.NEXT_STATEMENT` - A notch for a stack of statement blocks.
  * `Blockly.DUMMY_INPUT` - Not an input, just a label.

The first three types are demonstrated in the "for each" block above.  The dummy input type is usually only used when English (or other language) requires a word after the last input.  An example is the "create list with item (X) repeated (Y) times" block.  In that case "create list" is a title, "with item" is the label for input X, "repeated" is the label for input Y and "times" is the label for a dummy input.

==== Name ====

The third argument to `appendInput` specifies the language-neutral name of the input.  Just like editable fields, inputs need a name which is consistent across all language versions.  These names allow inputs and titles to be reordered in different languages, for instance in one language a block might say "get (X) from (Y)" whereas in another language the same block might say "from (Y) get (X)".

Inputs of type `DUMMY_INPUT` do not require names and may use the empty string.

==== Check ====

The fourth argument to `appendInput` is optional and is used for type-checking of connected inputs.  If null or undefined, then this input may be connected to any block.  See [#setOutput setOutput] for details on the expected values.

=== setInputsInline ===

{{{
    this.setInputsInline(true);
}}}

http://blockly.googlecode.com/svn/wiki/setInputsInline.png

Value and variable inputs are by default each on separate lines (as shown on the left).  By setting inputs inline, one can create a more compact block (as shown on the right).

Use inline inputs when a block is likely going to have small inputs such as numbers.  The user can toggle this option through the context menu.

=== setTooltip ===

{{{
    this.setTooltip('Returns number of letters in the provided text.');
}}}

Tooltips offer instant help when the user hovers their mouse over the block.  Longer strings should include line breaks (`\n`) since the text does not wrap automatically.

Tooltips may also be defined as a function instead of a static string.  This allows for dynamic help.  See `math_arithmetic` for an example of a tooltip that changes depending on which dropdown option has been chosen.

=== setMutator ===

{{{
    this.setMutator(new Blockly.Mutator(['controls_if_elseif', 'controls_if_else']));
}}}

http://blockly.googlecode.com/svn/wiki/controls_if.png

Mutators allow advanced blocks to change shape, most notably as a result of users opening a dialog to add, remove or rearrange components.  Creating a mutator is not trivial and is the subject of a separate page: [CreatingMutators Creating Mutators].